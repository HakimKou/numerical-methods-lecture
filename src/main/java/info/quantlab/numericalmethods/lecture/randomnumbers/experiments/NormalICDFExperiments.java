package info.quantlab.numericalmethods.lecture.randomnumbers.experiments;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.DoubleUnaryOperator;

import info.quantlab.numericalmethods.lecture.randomnumbers.MersenneTwister;
import info.quantlab.numericalmethods.lecture.randomnumbers.RandomNumberGenerator1D;
import info.quantlab.numericalmethods.lecture.randomnumbers.VanDerCorputSequence;
import net.finmath.functions.NormalDistribution;
import net.finmath.plots.Plots;
import net.finmath.randomnumbers.SobolSequence1D;

/**
 * Experiments related to the ICDF methods: Apply the inverse of the cumulative distribution function.
 * 
 * <ul>
 *   <li>
 *   	Plot the uniform input distribution and the transformed normal distribution for different uniform random number sequences:
 *   	<ul>
 *   		<li>java.util.Random</li>
 *   		<li>MersenneTwister</li>
 *   		<li>VanDerCorputSequence</li>
 *   		<li>SobolSquence</li>
 *   	</ul>
 *   </li>
 *   <li>
 *   	For different implementations of the CDF and ICDF analyse the round trip CDF(ICDF(u)) for different input values u.
 *   </li>
 * </ul>
 * 
 * @author Christian Fries
 */
public class NormalICDFExperiments {

	public static void main(String[] args) throws Exception {

		/*
		 * Plot ICDF from different uniforms
		 */
		plotDensityUniformAndNormalViaICDFJavaRandom();
		plotDensityUniformAndNormalViaICDFMersenneTwister();
		plotDensityUniformAndNormalViaICDFVanDerCorput();
		plotDensityUniformAndNormalViaICDFSobol();

		/*
		 * Check the round trip u -> x(u) -> u(x) for different cdf/icdf
		 */
		testICDFImplementations();
	}

	private static void plotDensityUniformAndNormalViaICDF(RandomNumberGenerator1D randomNumberGenerator, DoubleUnaryOperator icdf) throws Exception {
		List<Double> valuesUniform = new ArrayList<>();
		List<Double> valuesNormal = new ArrayList<>();
		for(int i = 0; i<100000; i++) {
			double uniform = randomNumberGenerator.nextDouble();

			double normal = icdf.applyAsDouble(uniform);

			valuesUniform.add(uniform);
			valuesNormal.add(normal);
		}

		Plots.createDensity(valuesUniform, 300, 4.0)
		.setTitle("Uniform from " + randomNumberGenerator).show();

		Plots.createDensity(valuesNormal, 300, 4.0)
		.setTitle("Normal via ICDF from " + randomNumberGenerator).show();
	}

	private static void plotDensityUniformAndNormalViaICDFJavaRandom() throws Exception {
		Random random = new Random(3636);

		RandomNumberGenerator1D randomNumberGenerator1D = new RandomNumberGenerator1D() {
			@Override
			public double nextDouble() {
				return random.nextDouble();
			}
			
			@Override
			public String toString() {
				return "Java Random (LCG)";
			}
		};
		
		plotDensityUniformAndNormalViaICDF(randomNumberGenerator1D, NormalDistribution::inverseCumulativeDistribution);
	}

	private static void plotDensityUniformAndNormalViaICDFMersenneTwister() throws Exception {
		plotDensityUniformAndNormalViaICDF(new MersenneTwister(3636), NormalDistribution::inverseCumulativeDistribution);		
	}

	private static void plotDensityUniformAndNormalViaICDFVanDerCorput() throws Exception {
		plotDensityUniformAndNormalViaICDF(new VanDerCorputSequence(2), NormalDistribution::inverseCumulativeDistribution);
	}

	private static void plotDensityUniformAndNormalViaICDFSobol() throws Exception {
		SobolSequence1D sobol = new SobolSequence1D();
		sobol.nextDouble();	// remove first number in sequence being u=0.

		RandomNumberGenerator1D randomNumberGenerator1D = new RandomNumberGenerator1D() {
			@Override
			public double nextDouble() {
				return sobol.nextDouble();
			}
			
			@Override
			public String toString() {
				return "Sobol Sequence";
			}
		};
		
		org.apache.commons.math3.distribution.NormalDistribution normalDistribution =
				new org.apache.commons.math3.distribution.NormalDistribution();

		plotDensityUniformAndNormalViaICDF(randomNumberGenerator1D, x -> normalDistribution.inverseCumulativeProbability(x));
	}

	private static void testICDFImplementations() {
		double p;

		// Check where a uniform random number 0.0 is mapped to.
		p = 0.0;
		testICDFImplementations(p);
		System.out.println("=".repeat(80));

		// Check where a uniform random number Double.MIN_VALUE is mapped to.
		p = Double.MIN_VALUE;
		testICDFImplementations(p);
		System.out.println("=".repeat(80));

		// The smallest non-zero double value generated by java.util.Random
		p = Math.pow(2, -53);
		testICDFImplementations(p);
		System.out.println("=".repeat(80));

		// The largest double value generated by java.util.Random
		p = 1.0 - Math.pow(2, -53);
		testICDFImplementations(p);
		System.out.println("=".repeat(80));

		// Check where a uniform random number 1.0 is mapped to.
		p = 1.0;
		testICDFImplementations(p);
	}

	private static void testICDFImplementations(double uniform) {

		/*
		 * Testing Apache Common Math implementation
		 */
		org.apache.commons.math3.distribution.NormalDistribution normal = new org.apache.commons.math3.distribution.NormalDistribution();
		
		DoubleUnaryOperator icdfApacheCommonsMath = u -> normal.inverseCumulativeProbability(u);
		DoubleUnaryOperator cdfApacheCommonsMath = x -> normal.cumulativeProbability(x);
		
		System.out.println("Testing Apache Common Math implementation: u = " + uniform);
		System.out.println("_".repeat(80));

		testICDFImplementation(icdfApacheCommonsMath, cdfApacheCommonsMath, uniform);

		System.out.println("_".repeat(80));
		System.out.println();

		/*
		 * Testing finmath lib Wichura implementation
		 */
		System.out.println("Testing finmath lib Wichura implementation: u = " + uniform);
		System.out.println("_".repeat(80));
		
		testICDFImplementation(NormalDistribution::inverseCumulativeNormalDistributionWichura, cdfApacheCommonsMath, uniform);

		
	}
	private static void testICDFImplementation(DoubleUnaryOperator icdf, DoubleUnaryOperator cdf, double uniform) {

		System.out.println("u: uniform, x: normal");
		
		System.out.println("        u = " + uniform);

		double x = icdf.applyAsDouble(uniform);

		System.out.println("     x(u) = " + x);

		double p = cdf.applyAsDouble(x);

		System.out.println("  u(x(u)) = " + p);

		double expPlusX = Math.exp(x);

		System.out.println("   exp(x) = " + expPlusX);

		double expMinusX = Math.exp(-x);

		System.out.println("  exp(-x) = " + expMinusX);

		System.out.println();
	}

}
